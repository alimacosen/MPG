// Code generated by goa v3.11.3, DO NOT EDIT.
//
// CharacterService gRPC client CLI support package
//
// Command:
// $ goa gen characters/design

package client

import (
	characterservice "characters/gen/character_service"
	character_servicepb "characters/gen/grpc/character_service/pb"
	"encoding/json"
	"fmt"
)

// BuildCreateCharacterPayload builds the payload for the CharacterService
// createCharacter endpoint from CLI flags.
func BuildCreateCharacterPayload(characterServiceCreateCharacterMessage string) (*characterservice.CreateCharacterPayload, error) {
	var err error
	var message character_servicepb.CreateCharacterRequest
	{
		if characterServiceCreateCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceCreateCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Quidem ea autem error ullam ducimus.\",\n      \"name\": \"Ut aut suscipit consequatur voluptas ut porro.\"\n   }'")
			}
		}
	}
	v := &characterservice.CreateCharacterPayload{
		Name:        message.Name,
		Description: message.Description,
	}

	return v, nil
}

// BuildGetCharacterPayload builds the payload for the CharacterService
// getCharacter endpoint from CLI flags.
func BuildGetCharacterPayload(characterServiceGetCharacterMessage string) (*characterservice.GetCharacterPayload, error) {
	var err error
	var message character_servicepb.GetCharacterRequest
	{
		if characterServiceGetCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceGetCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Inventore aliquid libero dignissimos dolorem.\"\n   }'")
			}
		}
	}
	v := &characterservice.GetCharacterPayload{
		ID: message.Id,
	}

	return v, nil
}

// BuildUpdateCharacterAttributesPayload builds the payload for the
// CharacterService updateCharacterAttributes endpoint from CLI flags.
func BuildUpdateCharacterAttributesPayload(characterServiceUpdateCharacterAttributesMessage string) (*characterservice.UpdateCharacterAttributesPayload, error) {
	var err error
	var message character_servicepb.UpdateCharacterAttributesRequest
	{
		if characterServiceUpdateCharacterAttributesMessage != "" {
			err = json.Unmarshal([]byte(characterServiceUpdateCharacterAttributesMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Eos commodi.\",\n      \"experience\": 7265195379936315137,\n      \"health\": 6332591012168433997,\n      \"id\": \"Fuga non perspiciatis maiores ut laborum.\",\n      \"name\": \"Odio nostrum.\"\n   }'")
			}
		}
	}
	v := &characterservice.UpdateCharacterAttributesPayload{
		ID:          message.Id,
		Name:        message.Name,
		Description: message.Description,
	}
	if message.Health != nil {
		health := int(*message.Health)
		v.Health = &health
	}
	if message.Experience != nil {
		experience := int(*message.Experience)
		v.Experience = &experience
	}

	return v, nil
}

// BuildDeleteCharacterPayload builds the payload for the CharacterService
// deleteCharacter endpoint from CLI flags.
func BuildDeleteCharacterPayload(characterServiceDeleteCharacterMessage string) (*characterservice.DeleteCharacterPayload, error) {
	var err error
	var message character_servicepb.DeleteCharacterRequest
	{
		if characterServiceDeleteCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceDeleteCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Omnis et tenetur molestias sapiente eum eos.\"\n   }'")
			}
		}
	}
	v := &characterservice.DeleteCharacterPayload{
		ID: message.Id,
	}

	return v, nil
}
