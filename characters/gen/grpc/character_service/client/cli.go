// Code generated by goa v3.11.3, DO NOT EDIT.
//
// CharacterService gRPC client CLI support package
//
// Command:
// $ goa gen characters/design

package client

import (
	characterservice "characters/gen/character_service"
	character_servicepb "characters/gen/grpc/character_service/pb"
	"encoding/json"
	"fmt"
)

// BuildCreateCharacterPayload builds the payload for the CharacterService
// createCharacter endpoint from CLI flags.
func BuildCreateCharacterPayload(characterServiceCreateCharacterMessage string) (*characterservice.CreateCharacterPayload, error) {
	var err error
	var message character_servicepb.CreateCharacterRequest
	{
		if characterServiceCreateCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceCreateCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Ea autem error ullam ducimus corporis perspiciatis.\",\n      \"name\": \"Aut suscipit consequatur voluptas ut porro expedita.\"\n   }'")
			}
		}
	}
	v := &characterservice.CreateCharacterPayload{
		Name:        message.Name,
		Description: message.Description,
	}

	return v, nil
}

// BuildGetCharacterPayload builds the payload for the CharacterService
// getCharacter endpoint from CLI flags.
func BuildGetCharacterPayload(characterServiceGetCharacterMessage string) (*characterservice.GetCharacterPayload, error) {
	var err error
	var message character_servicepb.GetCharacterRequest
	{
		if characterServiceGetCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceGetCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Aliquid libero dignissimos dolorem nemo molestias voluptas.\"\n   }'")
			}
		}
	}
	v := &characterservice.GetCharacterPayload{
		ID: message.Id,
	}

	return v, nil
}

// BuildUpdateCharacterPayload builds the payload for the CharacterService
// updateCharacter endpoint from CLI flags.
func BuildUpdateCharacterPayload(characterServiceUpdateCharacterMessage string) (*characterservice.UpdateCharacterPayload, error) {
	var err error
	var message character_servicepb.UpdateCharacterRequest
	{
		if characterServiceUpdateCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceUpdateCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Ducimus quia.\",\n      \"experience\": 3777308563020406149,\n      \"health\": 6942598532338844437,\n      \"id\": \"Non perspiciatis maiores ut laborum fugiat odio.\",\n      \"name\": \"Et eos.\"\n   }'")
			}
		}
	}
	v := &characterservice.UpdateCharacterPayload{
		ID:          message.Id,
		Name:        message.Name,
		Description: message.Description,
	}
	if message.Health != nil {
		health := int(*message.Health)
		v.Health = &health
	}
	if message.Experience != nil {
		experience := int(*message.Experience)
		v.Experience = &experience
	}

	return v, nil
}

// BuildDeleteCharacterPayload builds the payload for the CharacterService
// deleteCharacter endpoint from CLI flags.
func BuildDeleteCharacterPayload(characterServiceDeleteCharacterMessage string) (*characterservice.DeleteCharacterPayload, error) {
	var err error
	var message character_servicepb.DeleteCharacterRequest
	{
		if characterServiceDeleteCharacterMessage != "" {
			err = json.Unmarshal([]byte(characterServiceDeleteCharacterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Ut et rerum.\"\n   }'")
			}
		}
	}
	v := &characterservice.DeleteCharacterPayload{
		ID: message.Id,
	}

	return v, nil
}
