// Code generated by goa v3.11.3, DO NOT EDIT.
//
// InventoryService gRPC client encoders and decoders
//
// Command:
// $ goa gen inventories/design

package client

import (
	"context"
	inventory_servicepb "inventories/gen/grpc/inventory_service/pb"
	inventoryservice "inventories/gen/inventory_service"

	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildCreateInventoryFunc builds the remote method to invoke for
// "InventoryService" service "createInventory" endpoint.
func BuildCreateInventoryFunc(grpccli inventory_servicepb.InventoryServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.CreateInventory(ctx, reqpb.(*inventory_servicepb.CreateInventoryRequest), opts...)
		}
		return grpccli.CreateInventory(ctx, &inventory_servicepb.CreateInventoryRequest{}, opts...)
	}
}

// EncodeCreateInventoryRequest encodes requests sent to InventoryService
// createInventory endpoint.
func EncodeCreateInventoryRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*inventoryservice.CreateInventoryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "createInventory", "*inventoryservice.CreateInventoryPayload", v)
	}
	return NewProtoCreateInventoryRequest(payload), nil
}

// DecodeCreateInventoryResponse decodes responses from the InventoryService
// createInventory endpoint.
func DecodeCreateInventoryResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*inventory_servicepb.CreateInventoryResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "createInventory", "*inventory_servicepb.CreateInventoryResponse", v)
	}
	res := NewCreateInventoryResult(message)
	return res, nil
}

// BuildGetInventoryFunc builds the remote method to invoke for
// "InventoryService" service "getInventory" endpoint.
func BuildGetInventoryFunc(grpccli inventory_servicepb.InventoryServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetInventory(ctx, reqpb.(*inventory_servicepb.GetInventoryRequest), opts...)
		}
		return grpccli.GetInventory(ctx, &inventory_servicepb.GetInventoryRequest{}, opts...)
	}
}

// EncodeGetInventoryRequest encodes requests sent to InventoryService
// getInventory endpoint.
func EncodeGetInventoryRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*inventoryservice.GetInventoryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "getInventory", "*inventoryservice.GetInventoryPayload", v)
	}
	return NewProtoGetInventoryRequest(payload), nil
}

// DecodeGetInventoryResponse decodes responses from the InventoryService
// getInventory endpoint.
func DecodeGetInventoryResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*inventory_servicepb.GetInventoryResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "getInventory", "*inventory_servicepb.GetInventoryResponse", v)
	}
	res := NewGetInventoryResult(message)
	return res, nil
}

// BuildUpdateInventoryFunc builds the remote method to invoke for
// "InventoryService" service "updateInventory" endpoint.
func BuildUpdateInventoryFunc(grpccli inventory_servicepb.InventoryServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.UpdateInventory(ctx, reqpb.(*inventory_servicepb.UpdateInventoryRequest), opts...)
		}
		return grpccli.UpdateInventory(ctx, &inventory_servicepb.UpdateInventoryRequest{}, opts...)
	}
}

// EncodeUpdateInventoryRequest encodes requests sent to InventoryService
// updateInventory endpoint.
func EncodeUpdateInventoryRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*inventoryservice.UpdateInventoryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "updateInventory", "*inventoryservice.UpdateInventoryPayload", v)
	}
	return NewProtoUpdateInventoryRequest(payload), nil
}

// DecodeUpdateInventoryResponse decodes responses from the InventoryService
// updateInventory endpoint.
func DecodeUpdateInventoryResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*inventory_servicepb.UpdateInventoryResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "updateInventory", "*inventory_servicepb.UpdateInventoryResponse", v)
	}
	res := NewUpdateInventoryResult(message)
	return res, nil
}

// BuildDeleteInventoryFunc builds the remote method to invoke for
// "InventoryService" service "deleteInventory" endpoint.
func BuildDeleteInventoryFunc(grpccli inventory_servicepb.InventoryServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.DeleteInventory(ctx, reqpb.(*inventory_servicepb.DeleteInventoryRequest), opts...)
		}
		return grpccli.DeleteInventory(ctx, &inventory_servicepb.DeleteInventoryRequest{}, opts...)
	}
}

// EncodeDeleteInventoryRequest encodes requests sent to InventoryService
// deleteInventory endpoint.
func EncodeDeleteInventoryRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*inventoryservice.DeleteInventoryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "deleteInventory", "*inventoryservice.DeleteInventoryPayload", v)
	}
	return NewProtoDeleteInventoryRequest(payload), nil
}

// DecodeDeleteInventoryResponse decodes responses from the InventoryService
// deleteInventory endpoint.
func DecodeDeleteInventoryResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	message, ok := v.(*inventory_servicepb.DeleteInventoryResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("InventoryService", "deleteInventory", "*inventory_servicepb.DeleteInventoryResponse", v)
	}
	res := NewDeleteInventoryResult(message)
	return res, nil
}
